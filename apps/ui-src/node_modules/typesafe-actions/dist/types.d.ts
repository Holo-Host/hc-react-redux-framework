export declare type StringType = string;
export declare type SymbolType = symbol;
export declare type StringOrSymbol = StringType | SymbolType;
export declare type EmptyAction<T extends StringType> = {
    type: T;
};
export declare type PayloadAction<T extends StringType, P> = {
    type: T;
    payload: P;
};
export declare type PayloadMetaAction<T extends StringType, P, M> = P extends void ? M extends void ? {
    type: T;
} : {
    type: T;
    meta: M;
} : M extends void ? {
    type: T;
    payload: P;
} : {
    type: T;
    payload: P;
    meta: M;
};
export interface FluxStandardAction<T extends StringType, P = void, M = void> {
    type: T;
    payload: P;
    meta: M;
    error?: true;
}
export interface TypeMeta<T extends StringOrSymbol> {
    getType?: () => T;
}
export declare type B<T> = {
    v: T;
};
export declare type U<T extends B<any>> = T['v'];
export declare type NoArgCreator<T extends StringType> = () => EmptyAction<T>;
export declare type PayloadCreator<T extends StringType, P> = (payload: P) => PayloadAction<T, P>;
export declare type PayloadMetaCreator<T extends StringType, P, M> = (payload: P, meta: M) => PayloadMetaAction<T, P, M>;
export declare type FsaBuilder<T extends StringType, P extends B<any> = B<void>, M extends B<any> = B<void>> = M extends B<void> ? P extends B<void> ? NoArgCreator<T> : PayloadCreator<T, U<P>> : PayloadMetaCreator<T, U<P>, U<M>>;
export declare type MapBuilder<T extends StringType, R extends B<any>, P extends B<any> = B<void>, M extends B<any> = B<void>> = M extends B<void> ? P extends B<void> ? () => MapAction<{
    type: T;
} & U<R>> : (payload: U<P>) => MapAction<{
    type: T;
} & U<R>> : (payload: U<P>, meta: U<M>) => MapAction<{
    type: T;
} & U<R>>;
export declare type MapAction<R extends {
    type: any;
}> = R;
export declare type ActionCreator<T extends StringType = StringType> = (...args: any[]) => {
    type: T;
};
export declare type ActionCreatorMap<T> = {
    [K in keyof T]: ActionType<T[K]>;
};
export declare type ActionType<ActionCreatorOrMap> = ActionCreatorOrMap extends ActionCreator ? ReturnType<ActionCreatorOrMap> : ActionCreatorOrMap extends object ? ActionCreatorMap<ActionCreatorOrMap>[keyof ActionCreatorOrMap] : never;
export declare type StateType<ReducerOrMap> = ReducerOrMap extends (...args: any[]) => any ? ReturnType<ReducerOrMap> : ReducerOrMap extends object ? {
    [K in keyof ReducerOrMap]: StateType<ReducerOrMap[K]>;
} : never;
