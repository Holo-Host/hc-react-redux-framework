{"version":3,"file":"index.umd.js","sources":["../src/action.ts","../src/utils.ts","../src/create-action-with-type.ts","../src/create-action.ts","../src/create-standard-action.ts","../src/create-async-action.ts","../src/get-type.ts","../src/is-of-type.ts","../src/is-action-of.ts","../src/create-action-deprecated.ts"],"sourcesContent":["import {\n  StringType,\n  EmptyAction,\n  PayloadAction,\n  PayloadMetaAction,\n} from './types';\n\nexport function action<T extends StringType>(type: T): EmptyAction<T>;\n\nexport function action<T extends StringType, P = undefined>(\n  type: T,\n  payload: P\n): PayloadAction<T, P>;\n\nexport function action<T extends StringType, P = undefined, M = undefined>(\n  type: T,\n  payload: P,\n  meta: M\n): PayloadMetaAction<T, P, M>;\n\n/**\n * @description flux standard action factory\n * @example\n * ```\n * const add = (amount: number, meta?: MetaShape) => action('INCREMENT', amount, meta);\n * ```\n */\nexport function action<T extends StringType, P = undefined, M = undefined>(\n  type: T,\n  payload?: P,\n  meta?: M\n) {\n  return { type, payload, meta } as any;\n}\n","/** @internal */\nexport function validateActionType(arg: any, idx: number = 1): void {\n  if (arg == null) {\n    throw new Error(`Argument (#${idx}) is missing`);\n  } else {\n    if (typeof arg !== 'string' && typeof arg !== 'symbol') {\n      throw new Error(`Argument (#${idx}) should be of type: string | symbol`);\n    }\n  }\n}\n","import { ActionCreator, StringOrSymbol } from './types';\n\n/**\n * @description decorate any action-creator to make it compatible with `typesafe-actions`\n * @description (usefull to make third-party action-creator work with typesafe helpers)\n */\nexport function createActionWithType<\n  T extends StringOrSymbol,\n  AC extends ActionCreator<T> = () => { type: T }\n>(type: T, actionCreatorHandler?: (type: T) => AC): AC {\n  const actionCreator: AC =\n    actionCreatorHandler != null\n      ? actionCreatorHandler(type)\n      : ((() => ({ type })) as AC);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import { StringType, ActionCreator } from './types';\nimport { validateActionType } from './utils';\nimport { action } from './action';\n\nexport type PayloadMetaAction<T extends StringType, P, M> = P extends undefined\n  ? M extends undefined\n    ? { type: T }\n    : { type: T; meta: M }\n  : M extends undefined\n  ? { type: T; payload: P }\n  : { type: T; payload: P; meta: M };\n\n/**\n * @description typesafe action-creator factory\n */\nexport function createAction<\n  T extends StringType,\n  AC extends ActionCreator<T> = () => { type: T }\n>(\n  actionType: T,\n  actionResolverHandler?: (\n    resolve: <P = undefined, M = undefined>(\n      payload?: P,\n      meta?: M\n    ) => PayloadMetaAction<T, P, M>\n  ) => AC\n): AC {\n  validateActionType(actionType);\n\n  const actionCreator: AC =\n    actionResolverHandler == null\n      ? ((() => action(actionType)) as AC)\n      : actionResolverHandler(action.bind(null, actionType) as any);\n\n  return Object.assign(actionCreator, {\n    getType: () => actionType,\n    // redux-actions compatibility\n    toString: () => actionType,\n  });\n}\n","import { StringType, Box, FsaBuilder, FsaMapBuilder } from './types';\nimport { createActionWithType } from './create-action-with-type';\nimport { validateActionType } from './utils';\n\nexport interface CreateStandardAction<T extends StringType> {\n  <P = void, M = void>(): FsaBuilder<T, Box<P>, Box<M>>;\n  map<R, P = void, M = void>(\n    fn: (payload: P, meta: M) => R\n  ): FsaMapBuilder<T, Box<R>, Box<P>, Box<M>>;\n}\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createStandardAction<T extends StringType>(\n  actionType: T\n): CreateStandardAction<T> {\n  validateActionType(actionType);\n\n  function constructor<P, M = void>(): FsaBuilder<T, Box<P>, Box<M>> {\n    return createActionWithType(actionType, type => (payload: P, meta: M) => ({\n      type,\n      payload,\n      meta,\n    })) as FsaBuilder<T, Box<P>, Box<M>>;\n  }\n\n  function map<R, P, M>(\n    fn: (payload: P, meta: M) => R\n  ): FsaMapBuilder<T, Box<R>, Box<P>, Box<M>> {\n    return createActionWithType(actionType, type => (payload: P, meta: M) =>\n      Object.assign(fn(payload, meta), { type })\n    ) as FsaMapBuilder<T, Box<R>, Box<P>, Box<M>>;\n  }\n\n  return Object.assign(constructor, { map });\n}\n","import { StringType, Box, FsaMapBuilder, FsaBuilder } from './types';\nimport { createActionWithType } from './create-action-with-type';\nimport { validateActionType } from './utils';\n\nexport interface CreateAsyncAction<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType\n> {\n  // tslint:disable-next-line:callable-types\n  <P1, P2, P3>(): AsyncActionBuilder<T1, T2, T3, P1, P2, P3>;\n  // withMappers<A1 = void, P1 = void, A2 = void, P2 = void, A3 = void, P3 = void>(\n  //   requestMapper: (a?: A1) => P1,\n  //   successMapper: (a?: A2) => P2,\n  //   failureMapper: (a?: A3) => P3\n  // ): AsyncActionWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3>;\n}\n\nexport type AsyncActionBuilder<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType,\n  P1,\n  P2,\n  P3\n> = {\n  request: FsaBuilder<T1, Box<P1>>;\n  success: FsaBuilder<T2, Box<P2>>;\n  failure: FsaBuilder<T3, Box<P3>>;\n};\n\nexport type AsyncActionWithMappers<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType,\n  A1 = void,\n  P1 = void,\n  A2 = void,\n  P2 = void,\n  A3 = void,\n  P3 = void\n> = {\n  request: FsaMapBuilder<T1, Box<A1>, Box<P1>>;\n  success: FsaMapBuilder<T2, Box<A2>, Box<P2>>;\n  failure: FsaMapBuilder<T3, Box<A3>, Box<P3>>;\n};\n\n/** implementation */\nexport function createAsyncAction<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType\n>(\n  requestType: T1,\n  successType: T2,\n  failureType: T3\n): CreateAsyncAction<T1, T2, T3> {\n  [requestType, successType, failureType].forEach((arg, idx) => {\n    validateActionType(arg, idx + 1);\n  });\n\n  function constructor<P1, P2, P3>(): AsyncActionBuilder<\n    T1,\n    T2,\n    T3,\n    P1,\n    P2,\n    P3\n  > {\n    return {\n      request: createActionWithType(requestType, type => (payload?: P1) => ({\n        type: requestType,\n        payload,\n      })) as FsaBuilder<T1, Box<P1>>,\n      success: createActionWithType(successType, type => (payload?: P2) => ({\n        type: successType,\n        payload,\n      })) as FsaBuilder<T2, Box<P2>>,\n      failure: createActionWithType(failureType, type => (payload?: P3) => ({\n        type: failureType,\n        payload,\n      })) as FsaBuilder<T3, Box<P3>>,\n    };\n  }\n\n  // function withMappers<A1, P1, A2, P2, A3, P3>(\n  //   requestMapper: (a?: A1) => P1,\n  //   successMapper: (a?: A2) => P2,\n  //   failureMapper: (a?: A3) => P3\n  // ): AsyncActionWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3> {\n  //   return {\n  //     request: createActionWithType(requestType, type => (payload?: A1) => ({\n  //       type,\n  //       payload: requestMapper != null ? requestMapper(payload) : undefined,\n  //     })) as MapBuilder<T1, B<A1>, B<P1>>,\n  //     success: createActionWithType(successType, type => (payload?: A2) => ({\n  //       type,\n  //       payload: successMapper != null ? successMapper(payload) : undefined,\n  //     })) as MapBuilder<T2, B<A2>, B<P2>>,\n  //     failure: createActionWithType(failureType, type => (payload?: A3) => ({\n  //       type,\n  //       payload: failureMapper != null ? failureMapper(payload) : undefined,\n  //     })) as MapBuilder<T3, B<A3>, B<P3>>,\n  //   };\n  // }\n\n  return Object.assign(constructor, {});\n}\n","import { StringType, ActionCreator, TypeMeta } from './types';\n\n/**\n * @description get the \"type literal\" of a given action-creator\n */\nexport function getType<T extends StringType>(\n  creator: ActionCreator<T> & TypeMeta<T>\n): T {\n  if (creator == null) {\n    throw new Error('first argument is missing');\n  }\n\n  if (creator.getType == null) {\n    throw new Error('first argument is not an instance of \"typesafe-actions\"');\n  }\n\n  return creator.getType();\n}\n","import { StringType } from './types';\nimport { validateActionType } from './utils';\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends StringType, A extends { type: StringType }>(\n  type: T,\n  action: A\n): action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<\n  T extends K[],\n  K extends StringType,\n  A extends { type: StringType }\n>(type: T, action: A): action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends StringType>(\n  type: T\n): <A extends { type: StringType }>(\n  action: A\n) => action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends K[], K extends StringType>(\n  type: T\n): <A extends { type: StringType }>(\n  action: A\n) => action is A extends { type: T } ? A : never;\n\n/** implementation */\nexport function isOfType<\n  T extends StringType | StringType[],\n  A extends { type: StringType }\n>(actionType: T, actionOrNil?: A) {\n  Array.isArray(actionType)\n    ? actionType.forEach(type => validateActionType(type))\n    : validateActionType(actionType);\n\n  const assertFn = Array.isArray(actionType)\n    ? (action: A) => actionType.includes(action.type)\n    : (action: A) => action.type === actionType;\n\n  // with 1 arg return assertFn\n  if (actionOrNil == null) {\n    return assertFn;\n  }\n  // with 2 args invoke assertFn and return the result\n  return assertFn(actionOrNil);\n}\n","import { TypeMeta } from './types';\n\nexport type AC<T extends { type: string }> = ((...args: any[]) => T) &\n  TypeMeta<T['type']>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n * @inner If you need more than 5 arguments -> use switch\n */\nexport function isActionOf<A extends { type: string }, T1 extends A>(\n  actionCreators: [AC<T1>],\n  action: { type: string }\n): action is [T1][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>],\n  action: { type: string }\n): action is [T1, T2][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>],\n  action: { type: string }\n): action is [T1, T2, T3][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A,\n  T4 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>, AC<T4>],\n  action: { type: string }\n): action is [T1, T2, T3, T4][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A,\n  T4 extends A,\n  T5 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>, AC<T4>, AC<T5>],\n  action: { type: string }\n): action is [T1, T2, T3, T4, T5][number];\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<A extends { type: string }, T1 extends A>(\n  actionCreator: AC<T1>,\n  action: { type: string }\n): action is T1;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n * @inner If you need more than 5 arguments -> use switch\n */\nexport function isActionOf<A extends { type: string }, T1 extends A>(\n  actionCreators: [AC<T1>]\n): (action: A) => action is [T1][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A\n>(actionCreators: [AC<T1>, AC<T2>]): (action: A) => action is [T1, T2][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>]\n): (action: A) => action is [T1, T2, T3][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A,\n  T4 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>, AC<T4>]\n): (action: A) => action is [T1, T2, T3, T4][number];\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A,\n  T4 extends A,\n  T5 extends A\n>(\n  actionCreators: [AC<T1>, AC<T2>, AC<T3>, AC<T4>, AC<T5>]\n): (action: A) => action is [T1, T2, T3, T4, T5][number];\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<A extends { type: string }, T1 extends A>(\n  actionCreator: AC<T1>\n): (action: A) => action is T1;\n\n/** implementation */\nexport function isActionOf<\n  A extends { type: string },\n  T1 extends A,\n  T2 extends A,\n  T3 extends A,\n  T4 extends A,\n  T5 extends A\n>(\n  creatorOrCreators:\n    | AC<T1>\n    | [AC<T1>]\n    | [AC<T1>, AC<T2>]\n    | [AC<T1>, AC<T2>, AC<T3>]\n    | [AC<T1>, AC<T2>, AC<T3>, AC<T4>]\n    | [AC<T1>, AC<T2>, AC<T3>, AC<T4>, AC<T5>],\n  actionOrNil?: A\n) {\n  if (creatorOrCreators == null) {\n    throw new Error('first argument is missing');\n  }\n\n  if (Array.isArray(creatorOrCreators)) {\n    (creatorOrCreators as any[]).forEach((actionCreator, index) => {\n      if (actionCreator.getType == null) {\n        throw new Error(`first argument contains element\n        that is not created with \"typesafe-actions\" at index [${index}]`);\n      }\n    });\n  } else {\n    if (creatorOrCreators.getType == null) {\n      throw new Error('first argument is not created with \"typesafe-actions\"');\n    }\n  }\n\n  const assertFn = (action: A): action is [T1, T2, T3, T4, T5][number] => {\n    const actionCreators: any[] = Array.isArray(creatorOrCreators)\n      ? creatorOrCreators\n      : [creatorOrCreators];\n\n    return actionCreators.some((actionCreator, index) => {\n      return actionCreator.getType() === action.type;\n    });\n  };\n\n  // with 1 arg return assertFn\n  if (actionOrNil == null) {\n    return assertFn;\n  }\n  // with 2 args invoke assertFn and return the result\n  return assertFn(actionOrNil);\n}\n","import { StringOrSymbol } from './types';\n\nexport interface FSA<T extends StringOrSymbol, P = {}, M = {}, E = boolean> {\n  type: T;\n  payload?: P;\n  meta?: M;\n  error?: E;\n}\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends StringOrSymbol,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction: AC): AC;\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends StringOrSymbol,\n  AC extends () => { type: T }\n>(actionType: T): AC;\n\n/**\n *  implementation\n */\nexport function createActionDeprecated<\n  T extends StringOrSymbol,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction?: AC): AC {\n  let actionCreator: AC;\n\n  if (creatorFunction != null) {\n    if (typeof creatorFunction !== 'function') {\n      throw new Error('second argument is not a function');\n    }\n\n    actionCreator = creatorFunction as AC;\n  } else {\n    actionCreator = (() => ({ type: actionType })) as AC;\n  }\n\n  if (actionType != null) {\n    if (typeof actionType !== 'string' && typeof actionType !== 'symbol') {\n      throw new Error('first argument should be type of: string | symbol');\n    }\n  } else {\n    throw new Error('first argument is missing');\n  }\n\n  return actionCreator;\n}\n"],"names":["type","payload","meta","arg","idx","Error","actionCreatorHandler","actionCreator","Object","assign","getType","toString","actionType","actionResolverHandler","validateActionType","action","bind","createActionWithType","map","fn","requestType","successType","failureType","forEach","request","success","failure","creator","actionOrNil","Array","isArray","assertFn","includes","creatorOrCreators","index","some","creatorFunction"],"mappings":"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"}