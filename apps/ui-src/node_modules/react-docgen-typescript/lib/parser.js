"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var ts = require("typescript");
var buildFilter_1 = require("./buildFilter");
exports.defaultParserOpts = {};
var defaultOptions = {
    jsx: ts.JsxEmit.React,
    module: ts.ModuleKind.CommonJS,
    target: ts.ScriptTarget.Latest
};
/**
 * Parses a file with default TS options
 * @param filePath component file that should be parsed
 */
function parse(filePathOrPaths, parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return withCompilerOptions(defaultOptions, parserOpts).parse(filePathOrPaths);
}
exports.parse = parse;
/**
 * Constructs a parser for a default configuration.
 */
function withDefaultConfig(parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return withCompilerOptions(defaultOptions, parserOpts);
}
exports.withDefaultConfig = withDefaultConfig;
/**
 * Constructs a parser for a specified tsconfig file.
 */
function withCustomConfig(tsconfigPath, parserOpts) {
    var basePath = path.dirname(tsconfigPath);
    var _a = ts.readConfigFile(tsconfigPath, function (filename) {
        return fs.readFileSync(filename, 'utf8');
    }), config = _a.config, error = _a.error;
    if (error !== undefined) {
        throw error;
    }
    var _b = ts.parseJsonConfigFileContent(config, ts.sys, basePath, {}, tsconfigPath), options = _b.options, errors = _b.errors;
    if (errors && errors.length) {
        throw errors[0];
    }
    return withCompilerOptions(options, parserOpts);
}
exports.withCustomConfig = withCustomConfig;
/**
 * Constructs a parser for a specified set of TS compiler options.
 */
function withCompilerOptions(compilerOptions, parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return {
        parse: function (filePathOrPaths) {
            var filePaths = Array.isArray(filePathOrPaths)
                ? filePathOrPaths
                : [filePathOrPaths];
            var program = ts.createProgram(filePaths, compilerOptions);
            var parser = new Parser(program, parserOpts);
            var checker = program.getTypeChecker();
            return filePaths
                .map(function (filePath) { return program.getSourceFile(filePath); })
                .filter(function (sourceFile) {
                return typeof sourceFile !== 'undefined';
            })
                .reduce(function (docs, sourceFile) {
                var moduleSymbol = checker.getSymbolAtLocation(sourceFile);
                if (!moduleSymbol) {
                    return docs;
                }
                Array.prototype.push.apply(docs, checker
                    .getExportsOfModule(moduleSymbol)
                    .map(function (exp) { return parser.getComponentInfo(exp, sourceFile); })
                    .filter(function (comp) { return comp !== null; })
                    .filter(function (comp, index, comps) {
                    return comps
                        .slice(index + 1)
                        .every(function (innerComp) { return innerComp.displayName !== comp.displayName; });
                }));
                return docs;
            }, []);
        }
    };
}
exports.withCompilerOptions = withCompilerOptions;
var defaultJSDoc = {
    description: '',
    fullComment: '',
    tags: {}
};
var Parser = /** @class */ (function () {
    function Parser(program, opts) {
        this.checker = program.getTypeChecker();
        this.propFilter = buildFilter_1.buildFilter(opts);
    }
    Parser.prototype.getComponentInfo = function (exp, source) {
        if (!!exp.declarations && exp.declarations.length === 0) {
            return null;
        }
        var type = this.checker.getTypeOfSymbolAtLocation(exp, exp.valueDeclaration || exp.declarations[0]);
        var commentSource = exp;
        if (!exp.valueDeclaration) {
            if (!type.symbol) {
                return null;
            }
            exp = type.symbol;
            if (exp.getName() === 'StatelessComponent') {
                commentSource = this.checker.getAliasedSymbol(commentSource);
            }
            else {
                commentSource = exp;
            }
        }
        // Skip over PropTypes that are exported
        if (type.symbol &&
            (type.symbol.getEscapedName() === 'Requireable' ||
                type.symbol.getEscapedName() === 'Validator')) {
            return null;
        }
        var propsType = this.extractPropsFromTypeIfStatelessComponent(type) ||
            this.extractPropsFromTypeIfStatefulComponent(type);
        if (propsType) {
            var componentName = computeComponentName(exp, source);
            var defaultProps = this.extractDefaultPropsFromComponent(exp, source);
            var props = this.getPropsInfo(propsType, defaultProps);
            for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
                var propName = _a[_i];
                var prop = props[propName];
                var component = { name: componentName };
                if (!this.propFilter(prop, component)) {
                    delete props[propName];
                }
            }
            return {
                description: this.findDocComment(commentSource).fullComment,
                displayName: componentName,
                props: props
            };
        }
        return null;
    };
    Parser.prototype.extractPropsFromTypeIfStatelessComponent = function (type) {
        var callSignatures = type.getCallSignatures();
        if (callSignatures.length) {
            // Could be a stateless component.  Is a function, so the props object we're interested
            // in is the (only) parameter.
            for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {
                var sig = callSignatures_1[_i];
                var params = sig.getParameters();
                if (params.length === 0) {
                    continue;
                }
                // Maybe we could check return type instead,
                // but not sure if Element, ReactElement<T> are all possible values
                var propsParam = params[0];
                if (propsParam.name === 'props' || params.length === 1) {
                    return propsParam;
                }
            }
        }
        return null;
    };
    Parser.prototype.extractPropsFromTypeIfStatefulComponent = function (type) {
        var constructSignatures = type.getConstructSignatures();
        if (constructSignatures.length) {
            // React.Component. Is a class, so the props object we're interested
            // in is the type of 'props' property of the object constructed by the class.
            for (var _i = 0, constructSignatures_1 = constructSignatures; _i < constructSignatures_1.length; _i++) {
                var sig = constructSignatures_1[_i];
                var instanceType = sig.getReturnType();
                var props = instanceType.getProperty('props');
                if (props) {
                    return props;
                }
            }
        }
        return null;
    };
    Parser.prototype.getPropsInfo = function (propsObj, defaultProps) {
        var _this = this;
        if (defaultProps === void 0) { defaultProps = {}; }
        if (!propsObj.valueDeclaration) {
            return {};
        }
        var propsType = this.checker.getTypeOfSymbolAtLocation(propsObj, propsObj.valueDeclaration);
        var propertiesOfProps = propsType.getProperties();
        var result = {};
        propertiesOfProps.forEach(function (prop) {
            var propName = prop.getName();
            // Find type of prop by looking in context of the props object itself.
            var propType = _this.checker.getTypeOfSymbolAtLocation(prop, propsObj.valueDeclaration);
            var propTypeString = _this.checker.typeToString(propType);
            // tslint:disable-next-line:no-bitwise
            var isOptional = (prop.getFlags() & ts.SymbolFlags.Optional) !== 0;
            var jsDocComment = _this.findDocComment(prop);
            var defaultValue = null;
            if (defaultProps[propName] !== undefined) {
                defaultValue = { value: defaultProps[propName] };
            }
            else if (jsDocComment.tags.default) {
                defaultValue = { value: jsDocComment.tags.default };
            }
            var parent = getParentType(prop);
            result[propName] = {
                defaultValue: defaultValue,
                description: jsDocComment.fullComment,
                name: propName,
                parent: parent,
                required: !isOptional,
                type: { name: propTypeString }
            };
        });
        return result;
    };
    Parser.prototype.findDocComment = function (symbol) {
        var _this = this;
        var comment = this.getFullJsDocComment(symbol);
        if (comment.fullComment) {
            return comment;
        }
        var rootSymbols = this.checker.getRootSymbols(symbol);
        var commentsOnRootSymbols = rootSymbols
            .filter(function (x) { return x !== symbol; })
            .map(function (x) { return _this.getFullJsDocComment(x); })
            .filter(function (x) { return !!x.fullComment; });
        if (commentsOnRootSymbols.length) {
            return commentsOnRootSymbols[0];
        }
        return defaultJSDoc;
    };
    /**
     * Extracts a full JsDoc comment from a symbol, even
     * though TypeScript has broken down the JsDoc comment into plain
     * text and JsDoc tags.
     */
    Parser.prototype.getFullJsDocComment = function (symbol) {
        // in some cases this can be undefined (Pick<Type, 'prop1'|'prop2'>)
        if (symbol.getDocumentationComment === undefined) {
            return defaultJSDoc;
        }
        var mainComment = ts.displayPartsToString(symbol.getDocumentationComment(this.checker));
        var tags = symbol.getJsDocTags() || [];
        var tagComments = [];
        var tagMap = {};
        tags.forEach(function (tag) {
            var trimmedText = (tag.text || '').trim();
            var currentValue = tagMap[tag.name];
            tagMap[tag.name] = currentValue
                ? currentValue + '\n' + trimmedText
                : trimmedText;
            if (tag.name !== 'default') {
                tagComments.push(formatTag(tag));
            }
        });
        return {
            description: mainComment,
            fullComment: (mainComment + '\n' + tagComments.join('\n')).trim(),
            tags: tagMap
        };
    };
    Parser.prototype.extractDefaultPropsFromComponent = function (symbol, source) {
        var _this = this;
        var possibleStatements = source.statements
            // ensure that name property is available
            .filter(function (stmt) { return !!stmt.name; })
            .filter(function (stmt) {
            return _this.checker.getSymbolAtLocation(stmt.name) === symbol;
        });
        if (!possibleStatements.length) {
            // if no class declaration is found, try to find a
            // expression statement used in a React.StatelessComponent
            possibleStatements = source.statements.filter(function (stmt) {
                return ts.isExpressionStatement(stmt);
            });
        }
        if (!possibleStatements.length) {
            return {};
        }
        var statement = possibleStatements[0];
        if (statementIsClassDeclaration(statement) && statement.members.length) {
            var possibleDefaultProps = statement.members.filter(function (member) { return member.name && getPropertyName(member.name) === 'defaultProps'; });
            if (!possibleDefaultProps.length) {
                return {};
            }
            var defaultProps = possibleDefaultProps[0];
            var initializer = defaultProps.initializer;
            var properties = initializer.properties;
            while (ts.isIdentifier(initializer)) {
                var defaultPropsReference = this.checker.getSymbolAtLocation(initializer);
                if (defaultPropsReference) {
                    var declarations = defaultPropsReference.getDeclarations();
                    if (declarations) {
                        initializer = declarations[0]
                            .initializer;
                        properties = initializer.properties;
                    }
                }
            }
            var propMap = {};
            if (properties) {
                propMap = this.getPropMap(properties);
            }
            return propMap;
        }
        else if (statementIsStateless(statement)) {
            var propMap_1 = {};
            statement.getChildren().forEach(function (child) {
                var right = child.right;
                if (right) {
                    var properties = right.properties;
                    if (properties) {
                        propMap_1 = _this.getPropMap(properties);
                    }
                }
            });
            return propMap_1;
        }
        return {};
    };
    Parser.prototype.getLiteralValueFromPropertyAssignment = function (property) {
        var initializer = property.initializer;
        // Shorthand properties, so inflect their actual value
        if (!initializer) {
            if (ts.isShorthandPropertyAssignment(property)) {
                var symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                var decl = symbol && symbol.valueDeclaration;
                if (decl && decl.initializer) {
                    initializer = decl.initializer;
                }
            }
        }
        if (!initializer) {
            return null;
        }
        // Literal values
        switch (initializer.kind) {
            case ts.SyntaxKind.FalseKeyword:
                return 'false';
            case ts.SyntaxKind.TrueKeyword:
                return 'true';
            case ts.SyntaxKind.StringLiteral:
                return initializer.text.trim();
            case ts.SyntaxKind.PrefixUnaryExpression:
                return initializer.getFullText().trim();
            case ts.SyntaxKind.NumericLiteral:
                return "" + initializer.text;
            case ts.SyntaxKind.NullKeyword:
                return 'null';
            case ts.SyntaxKind.Identifier:
                // can potentially find other identifiers in the source and map those in the future
                return initializer.text === 'undefined'
                    ? 'undefined'
                    : null;
            case ts.SyntaxKind.ObjectLiteralExpression:
                // return the source text for an object literal
                return initializer.getText();
            default:
                return null;
        }
    };
    Parser.prototype.getPropMap = function (properties) {
        var _this = this;
        var propMap = properties.reduce(function (acc, property) {
            if (ts.isSpreadAssignment(property) || !property.name) {
                return acc;
            }
            var literalValue = _this.getLiteralValueFromPropertyAssignment(property);
            var propertyName = getPropertyName(property.name);
            if (typeof literalValue === 'string' && propertyName !== null) {
                acc[propertyName] = literalValue;
            }
            return acc;
        }, {});
        return propMap;
    };
    return Parser;
}());
function statementIsClassDeclaration(statement) {
    return !!statement.members;
}
function statementIsStateless(statement) {
    var children = statement.getChildren();
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        var left = child.left;
        if (left) {
            var name_1 = left.name;
            if (name_1.escapedText === 'defaultProps') {
                return true;
            }
        }
    }
    return false;
}
function getPropertyName(name) {
    switch (name.kind) {
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.Identifier:
            return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
            return name.getText();
        default:
            return null;
    }
}
function formatTag(tag) {
    var result = '@' + tag.name;
    if (tag.text) {
        result += ' ' + tag.text;
    }
    return result;
}
function getTextValueOfClassMember(classDeclaration, memberName) {
    var textValue = classDeclaration.members
        .filter(function (member) { return ts.isPropertyDeclaration(member); })
        .filter(function (member) {
        var name = ts.getNameOfDeclaration(member);
        return name && name.text === memberName;
    })
        .map(function (member) {
        var property = member;
        return (property.initializer && property.initializer.text);
    })[0];
    return textValue || '';
}
function getTextValueOfFunctionProperty(exp, source, propertyName) {
    var textValue = source.statements
        .filter(function (statement) { return ts.isExpressionStatement(statement); })
        .filter(function (statement) {
        var expr = statement
            .expression;
        return (expr.left.name.escapedText ===
            propertyName);
    })
        .filter(function (statement) {
        var expr = statement
            .expression;
        return (expr.left.expression
            .escapedText === exp.getName());
    })
        .filter(function (statement) {
        return ts.isStringLiteral(statement
            .expression.right);
    })
        .map(function (statement) {
        return statement
            .expression.right.text;
    })[0];
    return textValue || '';
}
function computeComponentName(exp, source) {
    var exportName = exp.getName();
    var statelessDisplayName = getTextValueOfFunctionProperty(exp, source, 'displayName');
    var statefulDisplayName = exp.valueDeclaration &&
        ts.isClassDeclaration(exp.valueDeclaration) &&
        getTextValueOfClassMember(exp.valueDeclaration, 'displayName');
    if (statelessDisplayName || statefulDisplayName) {
        return statelessDisplayName || statefulDisplayName || '';
    }
    if (exportName === 'default' ||
        exportName === '__function' ||
        exportName === 'StatelessComponent') {
        // Default export for a file: named after file
        var name_2 = path.basename(source.fileName, path.extname(source.fileName));
        return name_2 === 'index'
            ? path.basename(path.dirname(source.fileName))
            : name_2;
    }
    else {
        return exportName;
    }
}
function getParentType(prop) {
    var decalarations = prop.getDeclarations();
    if (decalarations == null || decalarations.length === 0) {
        return undefined;
    }
    // Props can be declared only in one place
    var parent = decalarations[0].parent;
    if (!isInterfaceOrTypeAliasDeclaration(parent)) {
        return undefined;
    }
    var parentName = parent.name.text;
    var fileName = parent.getSourceFile().fileName;
    return {
        fileName: fileName,
        name: parentName
    };
}
function isInterfaceOrTypeAliasDeclaration(node) {
    return (node.kind === ts.SyntaxKind.InterfaceDeclaration ||
        node.kind === ts.SyntaxKind.TypeAliasDeclaration);
}
//# sourceMappingURL=parser.js.map