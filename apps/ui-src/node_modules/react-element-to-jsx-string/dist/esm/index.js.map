{"version":3,"file":"index.js","sources":["../../src/formatter/spacer.js","../../node_modules/isobject/index.js","../../node_modules/is-plain-object/index.js","../../node_modules/is-regexp/index.js","../../node_modules/is-obj/index.js","../../node_modules/get-own-enumerable-property-symbols/lib/index.js","../../node_modules/stringify-object/index.js","../../src/formatter/sortObject.js","../../src/tree.js","../../src/parser/parseReactElement.js","../../src/formatter/formatFunction.js","../../src/formatter/formatComplexDataStructure.js","../../src/formatter/formatPropValue.js","../../src/formatter/formatProp.js","../../src/formatter/mergeSiblingPlainStringChildrenReducer.js","../../src/formatter/propNameSorter.js","../../src/formatter/formatReactElementNode.js","../../src/formatter/formatReactFragmentNode.js","../../src/formatter/formatTreeNode.js","../../src/formatter/formatTree.js","../../src/index.js"],"sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","'use strict';\nmodule.exports = function (re) {\n\treturn Object.prototype.toString.call(re) === '[object RegExp]';\n};\n","'use strict';\nmodule.exports = function (x) {\n\tvar type = typeof x;\n\treturn x !== null && (type === 'object' || type === 'function');\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = function (object) { return Object\n    .getOwnPropertySymbols(object)\n    .filter(function (keySymbol) { return object.propertyIsEnumerable(keySymbol); }); };\n//# sourceMappingURL=index.js.map","'use strict';\nconst isRegexp = require('is-regexp');\nconst isObj = require('is-obj');\nconst getOwnEnumPropSymbols = require('get-own-enumerable-property-symbols').default;\n\nmodule.exports = (val, opts, pad) => {\n\tconst seen = [];\n\n\treturn (function stringify(val, opts, pad) {\n\t\topts = opts || {};\n\t\topts.indent = opts.indent || '\\t';\n\t\tpad = pad || '';\n\n\t\tlet tokens;\n\n\t\tif (opts.inlineCharacterLimit === undefined) {\n\t\t\ttokens = {\n\t\t\t\tnewLine: '\\n',\n\t\t\t\tnewLineOrSpace: '\\n',\n\t\t\t\tpad,\n\t\t\t\tindent: pad + opts.indent\n\t\t\t};\n\t\t} else {\n\t\t\ttokens = {\n\t\t\t\tnewLine: '@@__STRINGIFY_OBJECT_NEW_LINE__@@',\n\t\t\t\tnewLineOrSpace: '@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@',\n\t\t\t\tpad: '@@__STRINGIFY_OBJECT_PAD__@@',\n\t\t\t\tindent: '@@__STRINGIFY_OBJECT_INDENT__@@'\n\t\t\t};\n\t\t}\n\n\t\tconst expandWhiteSpace = string => {\n\t\t\tif (opts.inlineCharacterLimit === undefined) {\n\t\t\t\treturn string;\n\t\t\t}\n\n\t\t\tconst oneLined = string\n\t\t\t\t.replace(new RegExp(tokens.newLine, 'g'), '')\n\t\t\t\t.replace(new RegExp(tokens.newLineOrSpace, 'g'), ' ')\n\t\t\t\t.replace(new RegExp(tokens.pad + '|' + tokens.indent, 'g'), '');\n\n\t\t\tif (oneLined.length <= opts.inlineCharacterLimit) {\n\t\t\t\treturn oneLined;\n\t\t\t}\n\n\t\t\treturn string\n\t\t\t\t.replace(new RegExp(tokens.newLine + '|' + tokens.newLineOrSpace, 'g'), '\\n')\n\t\t\t\t.replace(new RegExp(tokens.pad, 'g'), pad)\n\t\t\t\t.replace(new RegExp(tokens.indent, 'g'), pad + opts.indent);\n\t\t};\n\n\t\tif (seen.indexOf(val) !== -1) {\n\t\t\treturn '\"[Circular]\"';\n\t\t}\n\n\t\tif (val === null ||\n\t\t\tval === undefined ||\n\t\t\ttypeof val === 'number' ||\n\t\t\ttypeof val === 'boolean' ||\n\t\t\ttypeof val === 'function' ||\n\t\t\ttypeof val === 'symbol' ||\n\t\t\tisRegexp(val)) {\n\t\t\treturn String(val);\n\t\t}\n\n\t\tif (val instanceof Date) {\n\t\t\treturn `new Date('${val.toISOString()}')`;\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tif (val.length === 0) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\n\t\t\tseen.push(val);\n\n\t\t\tconst ret = '[' + tokens.newLine + val.map((el, i) => {\n\t\t\t\tconst eol = val.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n\t\t\t\tlet value = stringify(el, opts, pad + opts.indent);\n\t\t\t\tif (opts.transform) {\n\t\t\t\t\tvalue = opts.transform(val, i, value);\n\t\t\t\t}\n\t\t\t\treturn tokens.indent + value + eol;\n\t\t\t}).join('') + tokens.pad + ']';\n\n\t\t\tseen.pop(val);\n\n\t\t\treturn expandWhiteSpace(ret);\n\t\t}\n\n\t\tif (isObj(val)) {\n\t\t\tlet objKeys = Object.keys(val).concat(getOwnEnumPropSymbols(val));\n\n\t\t\tif (opts.filter) {\n\t\t\t\tobjKeys = objKeys.filter(el => opts.filter(val, el));\n\t\t\t}\n\n\t\t\tif (objKeys.length === 0) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\n\t\t\tseen.push(val);\n\n\t\t\tconst ret = '{' + tokens.newLine + objKeys.map((el, i) => {\n\t\t\t\tconst eol = objKeys.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n\t\t\t\tconst isSymbol = typeof el === 'symbol';\n\t\t\t\tconst isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);\n\t\t\t\tconst key = isSymbol || isClassic ? el : stringify(el, opts);\n\t\t\t\tlet value = stringify(val[el], opts, pad + opts.indent);\n\t\t\t\tif (opts.transform) {\n\t\t\t\t\tvalue = opts.transform(val, el, value);\n\t\t\t\t}\n\t\t\t\treturn tokens.indent + String(key) + ': ' + value + eol;\n\t\t\t}).join('') + tokens.pad + '}';\n\n\t\t\tseen.pop(val);\n\n\t\t\treturn expandWhiteSpace(ret);\n\t\t}\n\n\t\tval = String(val).replace(/[\\r\\n]/g, x => x === '\\n' ? '\\\\n' : '\\\\r');\n\n\t\tif (opts.singleQuotes === false) {\n\t\t\tval = val.replace(/\"/g, '\\\\\"');\n\t\t\treturn `\"${val}\"`;\n\t\t}\n\n\t\tval = val.replace(/\\\\?'/g, '\\\\\\'');\n\t\treturn `'${val}'`;\n\t})(val, opts, pad);\n};\n","/* @flow */\n\nexport default function sortObject(value: any): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date and regexp values as is\n  if (value instanceof Date || value instanceof RegExp) {\n    return value;\n  }\n\n  // make a copy of array with each item passed through sortObject()\n  if (Array.isArray(value)) {\n    return value.map(sortObject);\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      // eslint-disable-next-line no-param-reassign\n      result[key] = sortObject(value[key]);\n      return result;\n    }, {});\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getReactElementDisplayName = (element: ReactElement<*>): string =>\n  element.type.displayName ||\n  element.type.name || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nconst defaultFunctionValue = (fn: any): any => fn.toString();\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport stringify from 'stringify-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = stringify(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport isPlainObject from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nexport default (sortProps: boolean) => (a: string, b: string): -1 | 0 | 1 => {\n  if (a === b) {\n    return 0;\n  }\n\n  if (['key', 'ref'].includes(a)) {\n    return -1;\n  } else if (['key', 'ref'].includes(b)) {\n    return 1;\n  }\n\n  if (!sortProps) {\n    return 0;\n  }\n\n  return a < b ? -1 : 1;\n};\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport propNameSorter from './propNameSorter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${\n        type\n      }`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  Object.keys(props)\n    .filter(propName => filterProps.indexOf(propName) === -1)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(defaultPropName => filterProps.indexOf(defaultPropName) === -1)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = visibleAttributeNames.sort(propNameSorter(sortProps));\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${\n        type\n      }`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(\\S*)(\\s*)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s*)(\\S*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n"],"names":["times","tabStop","Array","fill","join","isObject","getOwnEnumPropSymbols","require","default","module","val","opts","pad","seen","stringify","indent","tokens","inlineCharacterLimit","undefined","expandWhiteSpace","string","oneLined","replace","RegExp","newLine","newLineOrSpace","length","indexOf","isRegexp","String","Date","toISOString","isArray","push","ret","map","el","i","eol","value","transform","pop","isObj","objKeys","Object","keys","concat","filter","isSymbol","isClassic","test","key","x","singleQuotes","sortObject","sort","reduce","result","createStringTreeNode","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","Fragment","getReactElementDisplayName","element","type","name","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","forEach","parseReactElement","options","displayNameFn","React","isValidElement","Error","ref","search","Children","toArray","child","noRefCheck","defaultFunctionValue","fn","toString","functionValue","showFunctions","inline","lvl","normalizedValue","stringifiedValue","currentObj","prop","originalResult","currentValue","formatTreeNode","formatFunction","spacer","escape","s","formatPropValue","propValue","symbolDescription","valueOf","isPlainObject","formatComplexDataStructure","hasValue","hasDefaultValue","defaultValue","usedValue","useBooleanShorthandSyntax","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","includes","previousNodes","currentNode","nodes","slice","previousNode","sortProps","a","b","compensateMultilineStringElementIndentation","formattedElement","split","line","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","maxInlineAttributesLineLength","shouldRenderMultilineAttr","containsMultilineAttr","node","showDefaultProps","out","outInlineAttr","outMultilineAttr","visibleAttributeNames","defaultPropName","propNameSorter","formatProp","attributeName","newLvl","mergeSiblingPlainStringChildrenReducer","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","hasNoChildren","useFragmentShortSyntax","formatReactElementNode","jsxStopChars","shouldBeEscaped","some","jsxStopChar","preserveTrailingSpace","endsWith","startsWith","formatReactFragmentNode","TypeError","reactElementToJsxString","formatTree"],"mappings":"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"}